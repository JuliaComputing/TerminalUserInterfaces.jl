{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TerminalUserInterfaces.jl Create TerminalUserInterfaces in Julia. Installation (v1.4)> add TerminalUserInterfaces Usage See documentation and examples folder for information how to use the package. References blessed-contrib tui-rs","title":"Home"},{"location":"#terminaluserinterfacesjl","text":"Create TerminalUserInterfaces in Julia.","title":"TerminalUserInterfaces.jl"},{"location":"#installation","text":"(v1.4)> add TerminalUserInterfaces","title":"Installation"},{"location":"#usage","text":"See documentation and examples folder for information how to use the package.","title":"Usage"},{"location":"#references","text":"blessed-contrib tui-rs","title":"References"},{"location":"api/","text":"API This is the API for the TerminalUserInterfaces # TerminalUserInterfaces.Terminal \u2014 Type . Terminal source # TerminalUserInterfaces.change_cursor_to_blinking_block \u2014 Method . Change cursor to blinking block source # TerminalUserInterfaces.change_cursor_to_blinking_ibeam \u2014 Method . Change cursor to blinking ibeam source # TerminalUserInterfaces.change_cursor_to_blinking_underline \u2014 Method . Change cursor to blinking underline source # TerminalUserInterfaces.change_cursor_to_steady_block \u2014 Method . Change cursor to steady block source # TerminalUserInterfaces.change_cursor_to_steady_ibeam \u2014 Method . Change cursor to steady ibeam source # TerminalUserInterfaces.change_cursor_to_steady_underline \u2014 Method . Change cursor to steady underline source # TerminalUserInterfaces.clear_line \u2014 Method . Clear line source # TerminalUserInterfaces.clear_line_from_cursor_left \u2014 Method . Clear line from cursor left onwards source # TerminalUserInterfaces.clear_line_from_cursor_right \u2014 Method . Clear line from cursor right onwards source # TerminalUserInterfaces.clear_screen \u2014 Method . Clear screen source # TerminalUserInterfaces.clear_screen_from_cursor_down \u2014 Method . Clear screen from cursor down onwards source # TerminalUserInterfaces.clear_screen_from_cursor_up \u2014 Method . Clear screen from cursor up onwards source # TerminalUserInterfaces.current_buffer \u2014 Method . Get current buffer source # TerminalUserInterfaces.default_mode \u2014 Method . Default mode source # TerminalUserInterfaces.draw \u2014 Method . Draw terminal source # TerminalUserInterfaces.draw \u2014 Method . Draw terminal source # TerminalUserInterfaces.flush \u2014 Function . Flush terminal contents source # TerminalUserInterfaces.get_event \u2014 Method . Get key press source # TerminalUserInterfaces.hide_cursor \u2014 Method . Hide cursor source # TerminalUserInterfaces.locate_cursor \u2014 Method . Locate cursor source # TerminalUserInterfaces.move_cursor \u2014 Method . Move cursor source # TerminalUserInterfaces.move_cursor_down \u2014 Function . Move cursor down source # TerminalUserInterfaces.move_cursor_home \u2014 Method . Move cursor home source # TerminalUserInterfaces.move_cursor_left \u2014 Function . Move cursor left source # TerminalUserInterfaces.move_cursor_right \u2014 Function . Move cursor right source # TerminalUserInterfaces.move_cursor_up \u2014 Function . Move cursor up source # TerminalUserInterfaces.reset \u2014 Method . Reset terminal source # TerminalUserInterfaces.reset \u2014 Method . Reset terminal settings source # TerminalUserInterfaces.resize \u2014 Method . Resize terminal source # TerminalUserInterfaces.restore_cursor \u2014 Method . Restore cursor source # TerminalUserInterfaces.save_cursor \u2014 Method . Save cursor source # TerminalUserInterfaces.show_cursor \u2014 Method . Show cursor source # TerminalUserInterfaces.tui_mode \u2014 Method . Alternate screen TUI mode source # TerminalUserInterfaces.update \u2014 Method . Update terminal source","title":"API"},{"location":"api/#api","text":"This is the API for the TerminalUserInterfaces # TerminalUserInterfaces.Terminal \u2014 Type . Terminal source # TerminalUserInterfaces.change_cursor_to_blinking_block \u2014 Method . Change cursor to blinking block source # TerminalUserInterfaces.change_cursor_to_blinking_ibeam \u2014 Method . Change cursor to blinking ibeam source # TerminalUserInterfaces.change_cursor_to_blinking_underline \u2014 Method . Change cursor to blinking underline source # TerminalUserInterfaces.change_cursor_to_steady_block \u2014 Method . Change cursor to steady block source # TerminalUserInterfaces.change_cursor_to_steady_ibeam \u2014 Method . Change cursor to steady ibeam source # TerminalUserInterfaces.change_cursor_to_steady_underline \u2014 Method . Change cursor to steady underline source # TerminalUserInterfaces.clear_line \u2014 Method . Clear line source # TerminalUserInterfaces.clear_line_from_cursor_left \u2014 Method . Clear line from cursor left onwards source # TerminalUserInterfaces.clear_line_from_cursor_right \u2014 Method . Clear line from cursor right onwards source # TerminalUserInterfaces.clear_screen \u2014 Method . Clear screen source # TerminalUserInterfaces.clear_screen_from_cursor_down \u2014 Method . Clear screen from cursor down onwards source # TerminalUserInterfaces.clear_screen_from_cursor_up \u2014 Method . Clear screen from cursor up onwards source # TerminalUserInterfaces.current_buffer \u2014 Method . Get current buffer source # TerminalUserInterfaces.default_mode \u2014 Method . Default mode source # TerminalUserInterfaces.draw \u2014 Method . Draw terminal source # TerminalUserInterfaces.draw \u2014 Method . Draw terminal source # TerminalUserInterfaces.flush \u2014 Function . Flush terminal contents source # TerminalUserInterfaces.get_event \u2014 Method . Get key press source # TerminalUserInterfaces.hide_cursor \u2014 Method . Hide cursor source # TerminalUserInterfaces.locate_cursor \u2014 Method . Locate cursor source # TerminalUserInterfaces.move_cursor \u2014 Method . Move cursor source # TerminalUserInterfaces.move_cursor_down \u2014 Function . Move cursor down source # TerminalUserInterfaces.move_cursor_home \u2014 Method . Move cursor home source # TerminalUserInterfaces.move_cursor_left \u2014 Function . Move cursor left source # TerminalUserInterfaces.move_cursor_right \u2014 Function . Move cursor right source # TerminalUserInterfaces.move_cursor_up \u2014 Function . Move cursor up source # TerminalUserInterfaces.reset \u2014 Method . Reset terminal source # TerminalUserInterfaces.reset \u2014 Method . Reset terminal settings source # TerminalUserInterfaces.resize \u2014 Method . Resize terminal source # TerminalUserInterfaces.restore_cursor \u2014 Method . Restore cursor source # TerminalUserInterfaces.save_cursor \u2014 Method . Save cursor source # TerminalUserInterfaces.show_cursor \u2014 Method . Show cursor source # TerminalUserInterfaces.tui_mode \u2014 Method . Alternate screen TUI mode source # TerminalUserInterfaces.update \u2014 Method . Update terminal source","title":"API"},{"location":"usage/","text":"Usage To use it in Julia, first add it: (v1.1)> add TerminalUserInterfaces To build a Terminal User Interface (TUI), you'll need a main loop. TerminalUserInterfaces.jl is a library based on the immediate mode rendering concept. Every iteration of the main loop, the User Interface is \"drawn\" from scratch. This means writing out text to the screen every frame. While this may appear to be a limitation from a performance perspective, in practice it works well with stateful UI. Also to increase performance, TerminalUserInterfaces.jl maintains two buffers and draws only the difference between frames. START TUI.draw.(t, w) END *-------*-----*---*----*-----* ^ / \\ v * <------* TUI.get_event(t) TUI.flush(t) Example using TerminalUserInterfaces const TUI = TerminalUserInterfaces Initialize To create a TUI, the first thing you need to do is call initialize TUI . initialize () This function does a few things: backup_termios () tui_mode () hide_cursor () enable_raw_mode () clear_screen () move_cursor_home () backup_termios() : backups termios settings to recover back to default terminal settings tui_mode() : starts an alternate buffer hide_cursor() : makes cursor not visible enable_raw_mode() : capture key presses as they happen without waiting for the enter key clear_screen() : clear the screen of all text move_cursor_home() : moves the cursor to the top left of the terminal window Every TUI.initialize() at beginning of a program must be paired with TUI.cleanup() at the end of a program. move_cursor_home () clear_screen () disable_raw_mode () show_cursor () default_mode () After calling initialize , we can create the application. To start, let's create an instance of Terminal . t = TUI . Terminal () This holds references to the frame buffers and allows us to call helper functions to create a TUI. Draw Widgets Let's look at an example of a SelectableList widget. w , _ = TUI . terminal_size () rect = TUI . Rect ( 1 , 1 , w \u00f7 4 , 20 ) widget = TUI . SelectableList ( TUI . Block ( title = \"Option Picker\" ), words , scroll , selection , ) TUI . draw ( t , widget , rect ) TUI.draw(t, widget, rect) calls draw(list::SelectableList, area::Rect, buf::Buffer) which implements how to draw the widget. The Buffer is a Matrix{Cell} where Cell contains a julia Char and information on how to style it. struct Cell char :: Char style :: Crayons . Crayon end This is useful to know when implementing your own widgets. You can draw as many widgets as you want. If widgets are drawn at the same location, they will overwrite the Cell characters in the Buffer . Finally, calling TUI.flush(t) draws the current frame to the terminal. TUI . flush ( t ) Getting user input TerminalUserInterfaces.jl sets up stdout and stdin Channel s Calling TUI.get_event(t) reads from the stdin Channel . function get_event ( t ) if isready ( t . stdin_channel ) return take! ( t . stdin_channel ) end end This function is non-blocking. You can also call take!(t.stdin_channel) to block till the user presses a key. Drawing, taking user input and acting on it and redrawing is what your main loop of the terminal user interface will look like. Minimum Working Example using TerminalUserInterfaces const TUI = TerminalUserInterfaces using Random function main () TUI . initialize () y , x = 1 , 1 count = 1 t = TUI . Terminal () # TUI.enableRawMode() TUI . clear_screen () TUI . hide_cursor () words = [ \"Option A\" \"Option B\" \"Option C\" \"Option D\" \"Option E\" \"Option F\" \"Option G\" \"Option H\" \"Option I\" ] rng = MersenneTwister () styles = [ # TUI.Crayon(bold = true) # TUI.Crayon(italics = true) # TUI.Crayon(foreground = :red) # TUI.Crayon(foreground = :blue) # TUI.Crayon(foreground = :green) # TUI.Crayon(bold = true, foreground = :red) # TUI.Crayon(bold = true, foreground = :blue) # TUI.Crayon(bold = true, foreground = :green) # TUI.Crayon(italics = true, foreground = :red) # TUI.Crayon(italics = true, foreground = :blue) # TUI.Crayon(italics = true, foreground = :green) TUI . Crayon () ] words = [ TUI . Word ( word , styles [ rand ( rng , 1 : length ( styles ))]) for word in words ] scroll = 1 selection = 1 final = \"\" while true w , _ = TUI . terminal_size () r = TUI . Rect ( x , y , w \u00f7 4 , 20 ) b = TUI . Block ( title = \"Option Picker\" ) p = TUI . SelectableList ( b , words , scroll , selection , ) TUI . draw ( t , p , r ) TUI . flush ( t ) count += 1 c = TUI . get_event ( t ) if c == 'j' selection += 1 elseif c == 'k' selection -= 1 elseif c == '\\r' final = words [ selection ] . text break end if selection < 1 selection = 1 end if selection > length ( words ) selection = length ( words ) end end TUI . cleanup () println ( final ) end main ()","title":"Usage"},{"location":"usage/#usage","text":"To use it in Julia, first add it: (v1.1)> add TerminalUserInterfaces To build a Terminal User Interface (TUI), you'll need a main loop. TerminalUserInterfaces.jl is a library based on the immediate mode rendering concept. Every iteration of the main loop, the User Interface is \"drawn\" from scratch. This means writing out text to the screen every frame. While this may appear to be a limitation from a performance perspective, in practice it works well with stateful UI. Also to increase performance, TerminalUserInterfaces.jl maintains two buffers and draws only the difference between frames. START TUI.draw.(t, w) END *-------*-----*---*----*-----* ^ / \\ v * <------* TUI.get_event(t) TUI.flush(t)","title":"Usage"},{"location":"usage/#example","text":"using TerminalUserInterfaces const TUI = TerminalUserInterfaces","title":"Example"},{"location":"usage/#initialize","text":"To create a TUI, the first thing you need to do is call initialize TUI . initialize () This function does a few things: backup_termios () tui_mode () hide_cursor () enable_raw_mode () clear_screen () move_cursor_home () backup_termios() : backups termios settings to recover back to default terminal settings tui_mode() : starts an alternate buffer hide_cursor() : makes cursor not visible enable_raw_mode() : capture key presses as they happen without waiting for the enter key clear_screen() : clear the screen of all text move_cursor_home() : moves the cursor to the top left of the terminal window Every TUI.initialize() at beginning of a program must be paired with TUI.cleanup() at the end of a program. move_cursor_home () clear_screen () disable_raw_mode () show_cursor () default_mode () After calling initialize , we can create the application. To start, let's create an instance of Terminal . t = TUI . Terminal () This holds references to the frame buffers and allows us to call helper functions to create a TUI.","title":"Initialize"},{"location":"usage/#draw-widgets","text":"Let's look at an example of a SelectableList widget. w , _ = TUI . terminal_size () rect = TUI . Rect ( 1 , 1 , w \u00f7 4 , 20 ) widget = TUI . SelectableList ( TUI . Block ( title = \"Option Picker\" ), words , scroll , selection , ) TUI . draw ( t , widget , rect ) TUI.draw(t, widget, rect) calls draw(list::SelectableList, area::Rect, buf::Buffer) which implements how to draw the widget. The Buffer is a Matrix{Cell} where Cell contains a julia Char and information on how to style it. struct Cell char :: Char style :: Crayons . Crayon end This is useful to know when implementing your own widgets. You can draw as many widgets as you want. If widgets are drawn at the same location, they will overwrite the Cell characters in the Buffer . Finally, calling TUI.flush(t) draws the current frame to the terminal. TUI . flush ( t )","title":"Draw Widgets"},{"location":"usage/#getting-user-input","text":"TerminalUserInterfaces.jl sets up stdout and stdin Channel s Calling TUI.get_event(t) reads from the stdin Channel . function get_event ( t ) if isready ( t . stdin_channel ) return take! ( t . stdin_channel ) end end This function is non-blocking. You can also call take!(t.stdin_channel) to block till the user presses a key. Drawing, taking user input and acting on it and redrawing is what your main loop of the terminal user interface will look like.","title":"Getting user input"},{"location":"usage/#minimum-working-example","text":"using TerminalUserInterfaces const TUI = TerminalUserInterfaces using Random function main () TUI . initialize () y , x = 1 , 1 count = 1 t = TUI . Terminal () # TUI.enableRawMode() TUI . clear_screen () TUI . hide_cursor () words = [ \"Option A\" \"Option B\" \"Option C\" \"Option D\" \"Option E\" \"Option F\" \"Option G\" \"Option H\" \"Option I\" ] rng = MersenneTwister () styles = [ # TUI.Crayon(bold = true) # TUI.Crayon(italics = true) # TUI.Crayon(foreground = :red) # TUI.Crayon(foreground = :blue) # TUI.Crayon(foreground = :green) # TUI.Crayon(bold = true, foreground = :red) # TUI.Crayon(bold = true, foreground = :blue) # TUI.Crayon(bold = true, foreground = :green) # TUI.Crayon(italics = true, foreground = :red) # TUI.Crayon(italics = true, foreground = :blue) # TUI.Crayon(italics = true, foreground = :green) TUI . Crayon () ] words = [ TUI . Word ( word , styles [ rand ( rng , 1 : length ( styles ))]) for word in words ] scroll = 1 selection = 1 final = \"\" while true w , _ = TUI . terminal_size () r = TUI . Rect ( x , y , w \u00f7 4 , 20 ) b = TUI . Block ( title = \"Option Picker\" ) p = TUI . SelectableList ( b , words , scroll , selection , ) TUI . draw ( t , p , r ) TUI . flush ( t ) count += 1 c = TUI . get_event ( t ) if c == 'j' selection += 1 elseif c == 'k' selection -= 1 elseif c == '\\r' final = words [ selection ] . text break end if selection < 1 selection = 1 end if selection > length ( words ) selection = length ( words ) end end TUI . cleanup () println ( final ) end main ()","title":"Minimum Working Example"}]}